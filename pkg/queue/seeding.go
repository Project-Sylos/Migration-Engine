// Copyright 2025 Sylos contributors
// SPDX-License-Identifier: LGPL-2.1-or-later

package queue

import (
	"fmt"

	"github.com/Project-Sylos/Migration-Engine/pkg/db"
	"github.com/Project-Sylos/Migration-Engine/pkg/logservice"
	"github.com/Project-Sylos/Sylos-FS/pkg/types"
)

// SeedRootTask inserts the initial root folder task into BoltDB to kickstart traversal.
// For src: sets traversal_status='Pending' and copy_status='Pending'
// For dst: sets traversal_status='Pending'
// Ensures stats bucket exists and is updated with root task counts.
// rootNodeID should be a ULID generated by calling db.GenerateNodeID() before calling this function.
func SeedRootTask(queueType string, rootFolder types.Folder, rootNodeID string, boltDB *db.DB) error {
	if boltDB == nil {
		return fmt.Errorf("boltDB cannot be nil")
	}

	if rootNodeID == "" {
		return fmt.Errorf("rootNodeID cannot be empty - must be generated by db.GenerateNodeID()")
	}

	// Ensure stats bucket exists before seeding
	// This is critical because root seeding happens before queues are initialized
	if err := boltDB.EnsureStatsBucket(); err != nil {
		return fmt.Errorf("failed to ensure stats bucket exists: %w", err)
	}

	// Create NodeState from root folder
	// Root is always at "/" (normalized), regardless of actual folder path
	state := &db.NodeState{
		ID:              rootNodeID,           // ULID for database keys
		ServiceID:       rootFolder.ServiceID, // FS identifier
		ParentID:        "",                   // Root has no parent
		ParentServiceID: rootFolder.ParentId,  // Parent's FS identifier (may be empty for root)
		ParentPath:      "",                   // Root has no parent
		Name:            rootFolder.DisplayName,
		Path:            "/", // Root is always "/" (normalized), regardless of actual folder path
		Type:            rootFolder.Type,
		Size:            0, // Folders have no size
		MTime:           rootFolder.LastUpdated,
		Depth:           0, // Root is always depth 0
		CopyNeeded:      false,
		Status:          db.StatusPending,
	}

	// Populate traversal status in the NodeState metadata
	state.TraversalStatus = db.StatusPending

	// Use BatchInsertNodes to write to BoltDB
	// BatchInsertNodes now updates stats automatically
	ops := []db.InsertOperation{
		{
			QueueType: queueType,
			Level:     0,
			Status:    db.StatusPending,
			State:     state,
		},
	}

	if err := db.BatchInsertNodes(boltDB, ops); err != nil {
		return fmt.Errorf("failed to seed root task to BoltDB for %s: %w", queueType, err)
	}

	if logservice.LS != nil {
		_ = logservice.LS.Log(
			"info",
			fmt.Sprintf("Seeded root task: %s (path: %s)", rootFolder.DisplayName, rootFolder.LocationPath),
			"seeding",
			queueType,
		)
	}

	return nil
}

// SeedRootTasks is a convenience function to seed both src and dst root tasks at once.
// Writes root tasks to BoltDB.
// Generates ULIDs for both root nodes and matches DST root to SRC root.
func SeedRootTasks(srcRoot types.Folder, dstRoot types.Folder, boltDB *db.DB) error {
	// Generate ULIDs for root nodes
	srcRootID := db.GenerateNodeID()
	if srcRootID == "" {
		return fmt.Errorf("failed to generate ULID for src root")
	}

	dstRootID := db.GenerateNodeID()
	if dstRootID == "" {
		return fmt.Errorf("failed to generate ULID for dst root")
	}

	// Seed SRC root first
	if err := SeedRootTask("SRC", srcRoot, srcRootID, boltDB); err != nil {
		return fmt.Errorf("failed to seed src root: %w", err)
	}

	// Seed DST root with SrcID pointing to SRC root
	// This ensures root nodes are matched from the start
	if err := SeedRootTaskWithSrcID("DST", dstRoot, dstRootID, srcRootID, boltDB); err != nil {
		return fmt.Errorf("failed to seed dst root: %w", err)
	}

	if logservice.LS != nil {
		_ = logservice.LS.Log(
			"info",
			"Successfully seeded both src and dst root tasks",
			"seeding",
			"main",
		)
	}

	return nil
}

// SeedRootTaskWithSrcID inserts the initial root folder task into BoltDB with a pre-set SrcID.
// This is used for DST root nodes that need to be matched to SRC root nodes.
func SeedRootTaskWithSrcID(queueType string, rootFolder types.Folder, rootNodeID string, srcID string, boltDB *db.DB) error {
	if boltDB == nil {
		return fmt.Errorf("boltDB cannot be nil")
	}

	if rootNodeID == "" {
		return fmt.Errorf("rootNodeID cannot be empty - must be generated by db.GenerateNodeID()")
	}

	if queueType != "DST" {
		return fmt.Errorf("SeedRootTaskWithSrcID should only be used for DST queue type")
	}

	// Ensure stats bucket exists before seeding
	if err := boltDB.EnsureStatsBucket(); err != nil {
		return fmt.Errorf("failed to ensure stats bucket exists: %w", err)
	}

	// Create NodeState from root folder (SrcID will be stored in lookup tables by BatchInsertNodes)
	state := &db.NodeState{
		ID:              rootNodeID,           // ULID for database keys
		ServiceID:       rootFolder.ServiceID, // FS identifier
		ParentID:        "",                   // Root has no parent
		ParentServiceID: rootFolder.ParentId,  // Parent's FS identifier (may be empty for root)
		ParentPath:      "",                   // Root has no parent
		Name:            rootFolder.DisplayName,
		Path:            "/", // Root is always "/" (normalized)
		Type:            rootFolder.Type,
		Size:            0, // Folders have no size
		MTime:           rootFolder.LastUpdated,
		Depth:           0, // Root is always depth 0
		CopyNeeded:      false,
		Status:          db.StatusPending,
		SrcID:           srcID, // Temporarily stored for BatchInsertNodes to create lookup mappings
	}

	// Populate traversal status in the NodeState metadata
	state.TraversalStatus = db.StatusPending

	// Use BatchInsertNodes to write to BoltDB (will also create lookup mappings)
	ops := []db.InsertOperation{
		{
			QueueType: queueType,
			Level:     0,
			Status:    db.StatusPending,
			State:     state,
		},
	}

	if err := db.BatchInsertNodes(boltDB, ops); err != nil {
		return fmt.Errorf("failed to seed root task to BoltDB for %s: %w", queueType, err)
	}

	if logservice.LS != nil {
		_ = logservice.LS.Log(
			"info",
			fmt.Sprintf("Seeded root task: %s (path: %s, src_id: %s)", rootFolder.DisplayName, rootFolder.LocationPath, srcID),
			"seeding",
			queueType,
		)
	}

	return nil
}
