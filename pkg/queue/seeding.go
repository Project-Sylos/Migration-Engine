// Copyright 2025 Sylos contributors
// SPDX-License-Identifier: LGPL-2.1-or-later

package queue

import (
	"fmt"

	"github.com/Project-Sylos/Migration-Engine/pkg/db"
	"github.com/Project-Sylos/Migration-Engine/pkg/logservice"
	"github.com/Project-Sylos/Sylos-FS/pkg/types"
	bolt "go.etcd.io/bbolt"
)

// SeedRootTask inserts the initial root folder task into BoltDB to kickstart traversal.
// For src: sets traversal_status='Pending' and copy_status='Pending'
// For dst: sets traversal_status='Pending'
// Ensures stats bucket exists and is updated with root task counts.
// rootNodeID should be a ULID generated by calling db.GenerateNodeID() before calling this function.
func SeedRootTask(queueType string, rootFolder types.Folder, rootNodeID string, boltDB *db.DB) error {
	if boltDB == nil {
		return fmt.Errorf("boltDB cannot be nil")
	}

	if rootNodeID == "" {
		return fmt.Errorf("rootNodeID cannot be empty - must be generated by db.GenerateNodeID()")
	}

	// Check if item with same 'path' already exists in the requested table.
	found := false
	err := boltDB.View(func(tx *bolt.Tx) error {
		key, _, err := boltDB.GetRootNode(queueType)
		if err != nil {
			// treat all errors (including not found) as not found for this purpose
			return nil
		}
		if key != nil {
			found = true
		}
		return nil
	})
	if err != nil {
		return fmt.Errorf("failed to check for existing root by path: %w", err)
	}
	if found {
		// Item with same 'path' already exists, so ignore the request.
		return nil
	}

	// Ensure stats bucket exists before seeding
	// This is critical because root seeding happens before queues are initialized
	if err := boltDB.EnsureStatsBucket(); err != nil {
		return fmt.Errorf("failed to ensure stats bucket exists: %w", err)
	}

	// Create NodeState from root folder
	// Root is always at "/" (normalized), regardless of actual folder path
	state := &db.NodeState{
		ID:              rootNodeID,           // ULID for database keys
		ServiceID:       rootFolder.ServiceID, // FS identifier
		ParentID:        "",                   // Root has no parent
		ParentServiceID: rootFolder.ParentId,  // Parent's FS identifier (may be empty for root)
		ParentPath:      "",                   // Root has no parent
		Name:            rootFolder.DisplayName,
		Path:            "/", // Root is always "/" (normalized), regardless of actual folder path
		Type:            rootFolder.Type,
		Size:            0, // Folders have no size
		MTime:           rootFolder.LastUpdated,
		Depth:           0, // Root is always depth 0
		CopyNeeded:      false,
		Status:          db.StatusPending,
	}

	// Populate traversal status in the NodeState metadata
	state.TraversalStatus = db.StatusPending

	// Use BatchInsertNodes to write to BoltDB
	// BatchInsertNodes now updates stats automatically
	ops := []db.InsertOperation{
		{
			QueueType: queueType,
			Level:     0,
			Status:    db.StatusPending,
			State:     state,
		},
	}

	if err := db.BatchInsertNodes(boltDB, ops); err != nil {
		return fmt.Errorf("failed to seed root task to BoltDB for %s: %w", queueType, err)
	}

	// Create path-to-ulid mapping for root (for API path-based queries)
	if err := boltDB.Update(func(tx *bolt.Tx) error {
		return db.SetPathToULIDMapping(tx, queueType, state.Path, rootNodeID)
	}); err != nil {
		return fmt.Errorf("failed to create path-to-ulid mapping for root: %w", err)
	}

	if logservice.LS != nil {
		_ = logservice.LS.Log(
			"info",
			fmt.Sprintf("Seeded root task: %s (path: %s)", rootFolder.DisplayName, rootFolder.LocationPath),
			"seeding",
			queueType,
		)
	}

	return nil
}

// SeedRootTasks is a convenience function to seed both src and dst root tasks at once.
// Writes root tasks to BoltDB.
// Generates ULIDs for both root nodes and matches DST root to SRC root.
func SeedRootTasks(srcRoot types.Folder, dstRoot types.Folder, boltDB *db.DB) error {
	// Only proceed if items with the same 'path' ("/") don't already exist in both tables
	srcExists := false
	dstExists := false

	err := boltDB.View(func(tx *bolt.Tx) error {
		if key, _, err := boltDB.GetRootNode("SRC"); err == nil && key != nil {
			srcExists = true
		}
		if key, _, err := boltDB.GetRootNode("DST"); err == nil && key != nil {
			dstExists = true
		}
		return nil
	})
	if err != nil {
		return fmt.Errorf("failed to check for existing root nodes: %w", err)
	}

	if srcExists && dstExists {
		// If both the SRC and DST have a root ("/") already present, ignore the request.
		return nil
	}

	// Generate ULIDs for root nodes
	srcRootID := db.GenerateNodeID()
	if srcRootID == "" {
		return fmt.Errorf("failed to generate ULID for src root")
	}

	dstRootID := db.GenerateNodeID()
	if dstRootID == "" {
		return fmt.Errorf("failed to generate ULID for dst root")
	}

	// Seed SRC root first
	if err := SeedRootTask("SRC", srcRoot, srcRootID, boltDB); err != nil {
		return fmt.Errorf("failed to seed src root: %w", err)
	}

	// Seed DST root with SrcID pointing to SRC root
	// This ensures root nodes are matched from the start
	if err := SeedRootTaskWithSrcID("DST", dstRoot, dstRootID, srcRootID, boltDB); err != nil {
		return fmt.Errorf("failed to seed dst root: %w", err)
	}

	if logservice.LS != nil {
		_ = logservice.LS.Log(
			"info",
			"Successfully seeded both src and dst root tasks",
			"seeding",
			"main",
		)
	}

	return nil
}

// SeedRootTaskWithSrcID inserts the initial root folder task into BoltDB with a pre-set SrcID.
// This is used for DST root nodes that need to be matched to SRC root nodes.
func SeedRootTaskWithSrcID(queueType string, rootFolder types.Folder, rootNodeID string, srcID string, boltDB *db.DB) error {
	if boltDB == nil {
		return fmt.Errorf("boltDB cannot be nil")
	}

	if rootNodeID == "" {
		return fmt.Errorf("rootNodeID cannot be empty - must be generated by db.GenerateNodeID()")
	}

	if queueType != "DST" {
		return fmt.Errorf("SeedRootTaskWithSrcID should only be used for DST queue type")
	}

	// Check if item with same 'path' already exists in the requested table.
	found := false
	err := boltDB.View(func(tx *bolt.Tx) error {
		key, _, err := boltDB.GetRootNode(queueType)
		if err != nil {
			return nil
		}
		if key != nil {
			found = true
		}
		return nil
	})
	if err != nil {
		return fmt.Errorf("failed to check for existing root by path: %w", err)
	}
	if found {
		// Item with same 'path' already exists, so ignore the request.
		return nil
	}

	// Ensure stats bucket exists before seeding
	if err := boltDB.EnsureStatsBucket(); err != nil {
		return fmt.Errorf("failed to ensure stats bucket exists: %w", err)
	}

	// Create NodeState from root folder (SrcID will be stored in lookup tables by BatchInsertNodes)
	state := &db.NodeState{
		ID:              rootNodeID,           // ULID for database keys
		ServiceID:       rootFolder.ServiceID, // FS identifier
		ParentID:        "",                   // Root has no parent
		ParentServiceID: rootFolder.ParentId,  // Parent's FS identifier (may be empty for root)
		ParentPath:      "",                   // Root has no parent
		Name:            rootFolder.DisplayName,
		Path:            "/", // Root is always "/" (normalized)
		Type:            rootFolder.Type,
		Size:            0, // Folders have no size
		MTime:           rootFolder.LastUpdated,
		Depth:           0, // Root is always depth 0
		CopyNeeded:      false,
		Status:          db.StatusPending,
		SrcID:           srcID, // Temporarily stored for BatchInsertNodes to create lookup mappings
	}

	// Populate traversal status in the NodeState metadata
	state.TraversalStatus = db.StatusPending

	// Use BatchInsertNodes to write to BoltDB (will also create lookup mappings)
	ops := []db.InsertOperation{
		{
			QueueType: queueType,
			Level:     0,
			Status:    db.StatusPending,
			State:     state,
		},
	}

	if err := db.BatchInsertNodes(boltDB, ops); err != nil {
		return fmt.Errorf("failed to seed root task to BoltDB for %s: %w", queueType, err)
	}

	// Create path-to-ulid mapping for root (for API path-based queries)
	if err := boltDB.Update(func(tx *bolt.Tx) error {
		return db.SetPathToULIDMapping(tx, queueType, state.Path, rootNodeID)
	}); err != nil {
		return fmt.Errorf("failed to create path-to-ulid mapping for root: %w", err)
	}

	if logservice.LS != nil {
		_ = logservice.LS.Log(
			"info",
			fmt.Sprintf("Seeded root task: %s (path: %s, src_id: %s)", rootFolder.DisplayName, rootFolder.LocationPath, srcID),
			"seeding",
			queueType,
		)
	}

	return nil
}
